package tests
package cmd

import (
	"bytes"
	"context"
	"fmt"
	"os"
	"testing"
	"time"

	applicationcache "github.com/den-vasyliev/ed210/pkg/applicationcache"
	auth "github.com/den-vasyliev/ed210/pkg/auth"
	env "github.com/den-vasyliev/ed210/pkg/environments/v1alpha1"
	promotionplanv1alpha1 "github.com/den-vasyliev/ed210/pkg/promotionplan/v1alpha1"
	rbacv1alpha1 "github.com/den-vasyliev/ed210/pkg/rbac/v1alpha1"
	"github.com/den-vasyliev/ed210/pkg/telemetry"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/rest"
	applicationsv1beta1 "sigs.k8s.io/application/api/v1beta1"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/client/fake"
	"sigs.k8s.io/controller-runtime/pkg/envtest"
	"sigs.k8s.io/controller-runtime/pkg/manager"
	"sigs.k8s.io/controller-runtime/pkg/metrics/server"
)

var Cli client.Client
var Apps applicationsv1beta1.ApplicationList
var V *auth.HMACValidator
var Fn func()
var T *testing.T

func init() {
	Apps = applicationsv1beta1.ApplicationList{}
	V = &auth.HMACValidator{}
	Fn = func() {}
	T = &testing.T{}

	appCache, Cli, Apps, V, environments, Fn = setupE2ETest(T, 1)
}

// setupTestEnv creates a new test environment and returns a cleanup function
func setupTestEnv(t *testing.T, timeout time.Duration, startIndex, startMgr bool) func() {
	// Create a new scheme that includes both core Kubernetes types and your CRDs
	testScheme = runtime.NewScheme()

	// Add the core Kubernetes schemes
	err := scheme.AddToScheme(testScheme)
	require.NoError(t, err)

	metav1.AddToGroupVersion(testScheme, promotionplanv1alpha1.GroupVersion)
	require.NoError(t, err)

	// Add CRD scheme
	err = apiextensionsv1.AddToScheme(testScheme)
	require.NoError(t, err)

	// Add your custom schemes
	err = promotionplanv1alpha1.AddToScheme(testScheme)
	require.NoError(t, err)

	// Add RBAC scheme
	err = rbacv1alpha1.AddToScheme(testScheme)
	require.NoError(t, err)

	// Add application scheme
	err = applicationsv1beta1.AddToScheme(testScheme)
	require.NoError(t, err)

	testEnv = &envtest.Environment{
		CRDDirectoryPaths: []string{
			"../crds/",
		},
		ErrorIfCRDPathMissing:    true,
		AttachControlPlaneOutput: false,
	}

	// Create a longer context timeout for environment startup
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	var startErr = make(chan error)
	go func() {
		var err error
		testConfig, err = testEnv.Start()
		startErr <- err
	}()

	// Wait for environment to start with timeout
	select {
	case err := <-startErr:
		require.NoError(t, err, "Failed to start test environment")
	case <-ctx.Done():
		t.Fatal("Timeout waiting for test environment to start")
	}

	// Create the client with the combined scheme
	testClient, err = client.New(testConfig, client.Options{Scheme: testScheme})
	if err != nil {
		t.Fatalf("Failed to create test client: %v", err)
	}

	// Override the getCluster function
	getCluster = func(_ context.Context, _, _ string, _ bool) (client.Client, *rest.Config, error) {
		return testClient, testConfig, nil
	}

	rootFlags.LeaderElectionNamespace = "default"
	rootFlags.LeaderElection = false

	environments = map[string]env.Environments{
		"dev": {
			Registry: "test-registry",
			Prefix:   "test-prefix",
		},
	}

	// Initialize manager
	testMgr, err = manager.New(testConfig, manager.Options{
		Scheme:                  testScheme,
		LeaderElection:          false,
		LeaderElectionNamespace: "default",
		HealthProbeBindAddress:  "0",
		Metrics:                 server.Options{BindAddress: "0"},
	})
	require.NoError(t, err)

	initOpenTelemetry(context.Background(), serverFlags.ServiceName, appVersion)

	testController = &PromotionController{
		Client: testClient,
		Scheme: testScheme,
		Cache:  testMgr.GetCache(),
	}

	// Verify connection
	testContext, cancel = context.WithTimeout(context.Background(), timeout)
	defer cancel()

	// Create test promotion plans
	plan1 := &promotionplanv1alpha1.PromotionPlan{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-plan-1",
			Namespace: "default",
		},
		Spec: promotionplanv1alpha1.PromotionPlanSpec{
			Records: []promotionplanv1alpha1.PromotionRecord{
				{
					Name:        "test-app-1",
					Status:      "new",
					Version:     "tagged-image-1.0.0",
					Namespace:   "dev",
					TaggedImage: "tagged-image-1.0.1",
					Image:       "test-image",
				},
				{
					Name:        "test-app-2",
					Status:      "new",
					Version:     "tagged-image-2.0.0",
					Namespace:   "default",
					TaggedImage: "tagged-image-2.0.1",
					Image:       "test-image",
				},
			},
		},
		Status: promotionplanv1alpha1.PromotionPlanStatus{
			CurrentState: "new",
			LastUpdated:  time.Now().UTC().Format("2006-01-02T15:04:05Z"),
		},
	}

	plan2 := &promotionplanv1alpha1.PromotionPlan{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-plan-2",
			Namespace: "default",
		},
		Spec: promotionplanv1alpha1.PromotionPlanSpec{
			Records: []promotionplanv1alpha1.PromotionRecord{
				{
					Name:        "test-app-3",
					Status:      "processing",
					Version:     "tagged-image-3.0.0",
					Namespace:   "default",
					TaggedImage: "tagged-image-3.0.1",
					Image:       "test-image-3",
				},
				{
					Name:        "test-app-4",
					Status:      "processing",
					Version:     "tagged-image-4.0.0",
					Namespace:   "dev",
					TaggedImage: "tagged-image-4.0.1",
					Image:       "test-image-4",
				},
			},
		},
		Status: promotionplanv1alpha1.PromotionPlanStatus{
			CurrentState:     "processing",
			CompletedRecords: 0,
			LastUpdated:      time.Now().UTC().Format("2006-01-02T15:04:05Z"),
		},
	}

	// Create test application
	testApp = &applicationsv1beta1.Application{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "test-app-3",
			Namespace: "default",
			Labels: map[string]string{
				"app.kubernetes.io/name": "test-app-3",
				"version":                "tagged-image-3.0.0",
				"image":                  "test-image",
			},
		},
		Spec: applicationsv1beta1.ApplicationSpec{
			ComponentGroupKinds: []metav1.GroupKind{
				{
					Group: "v1",
					Kind:  "Deployment",
				},
			},
		},
	}

	// Create the application in the test cluster
	testClient.Delete(context.Background(), testApp)
	err = testClient.Create(context.Background(), testApp)
	require.NoError(t, err)

	testAppCache = applicationcache.NewApplicationCache()
	// Test insertion
	testAppCache.UpsertApplication("dev", testApp)

	// Create the plans in the test cluster
	testClient.Delete(context.Background(), plan1)
	testClient.Delete(context.Background(), plan2)
	err = testClient.Create(context.Background(), plan1)
	require.NoError(t, err)
	err = testClient.Create(context.Background(), plan2)
	require.NoError(t, err)

	// Start manager in a goroutine
	var mgrCtx context.Context
	var mgrCancel context.CancelFunc
	if startMgr {
		mgrCtx, mgrCancel = context.WithCancel(context.Background())
		go func() {
			if err := testMgr.Start(mgrCtx); err != nil {
				t.Logf("Manager stopped with error: %v", err)
			}
		}()
	}

	// Add index to the cache
	if startIndex {
		err = addTaggedImageFieldIndex(testMgr)
		require.NoError(t, err, "Failed to add tagged image field index")
	}

	// Wait for cache to sync with increased timeout
	syncCtx, syncCancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer syncCancel()

	if startMgr {
		if !testMgr.GetCache().WaitForCacheSync(syncCtx) {
			t.Fatal("Timeout waiting for cache to sync")
		}
	}

	// Try to list namespaces to verify connection
	var pp promotionplanv1alpha1.PromotionPlanList
	if err := testClient.List(context.Background(), &pp); err != nil {
		t.Fatalf("Failed to connect to test API server: %v", err)
	}

	// Return cleanup function
	return func() {
		mgrCancel() // Stop the manager
		cancel()    // Stop the manager
		err := testEnv.Stop()
		require.NoError(t, err)

		// Clean up test resources
		if testClient != nil {
			testClient.Delete(context.Background(), testApp)
			testClient.Delete(context.Background(), plan1)
			testClient.Delete(context.Background(), plan2)
		}
	}
}

// setupE2ETest creates a new test environment and returns a cleanup function
func setupE2ETest(t testing.TB, items int) (*applicationcache.ApplicationCache, client.Client, applicationsv1beta1.ApplicationList, *auth.HMACValidator, map[string]env.Environments, func()) {
	// Create test configuration with environments
	environments = map[string]env.Environments{
		"dev": {
			Cluster: env.Cluster{
				Name:      "cluster1",
				ProjectID: "test-project",
				Zone:      "test-zone",
				Namespace: "dev",
			},
			Registry: "test-registry",
			Prefix:   "test-prefix",
		},
		"stable": {
			Cluster: env.Cluster{
				Name:      "cluster2",
				ProjectID: "test-project",
				Zone:      "test-zone",
				Namespace: "stable",
			},
			Registry: "test-registry",
			Prefix:   "test-prefix",
		},
		"prod": {
			Cluster: env.Cluster{
				Name:      "cluster3",
				ProjectID: "test-project",
				Zone:      "test-zone",
				Namespace: "prod",
			},
			Registry: "test-registry",
			Prefix:   "test-prefix",
		},
	}

	// Set up RBAC config
	RBAC := auth.RBACConfig{
		Tokens: []auth.Token{
			{Name: "operator", Token: "dGVzdA=="},
		},
		Roles: []auth.Role{
			{Name: "operator", AllowedCommands: []string{"list", "diff", "state", "version", "help"}, ReadOnly: true},
		},
		Contexts: []auth.Context{
			{TokenName: "operator", RoleName: "operator"},
		},
	}

	// Create validator
	validator := auth.NewHMACValidator(&RBAC)

	// Set up mock Kubernetes client
	scheme := runtime.NewScheme()
	applicationsv1beta1.AddToScheme(scheme)
	promotionplanv1alpha1.AddToScheme(scheme)

	// Create fake Application objects for each environment
	objects := []client.Object{}
	for _, env := range environments {
		objects = append(objects, generateApplications(env.Cluster.Namespace, items, "-app", []metav1.GroupKind{{Group: "v1", Kind: "Deployment"}})...)
		objects = append(objects, generateApplications(env.Cluster.Namespace, 5, "-job", []metav1.GroupKind{{Group: "batch", Kind: "CronJob"}})...)
	}
	fakeClient := fake.NewClientBuilder().WithScheme(scheme).WithObjects(objects...).Build()

	apps, err := getApplicationsList(fakeClient, "dev")
	assert.NoError(t, err)
	// Setup test cache
	ac := applicationcache.NewApplicationCache()

	testAppsCache := map[string]map[string]*applicationcache.ApplicationData{
		"cluster1/dev": {
			"test-service-1-app": {
				Name:        "test-service-1-app",
				Namespace:   "dev",
				Kind:        "v1",
				Version:     "master-3.0.0-3c3f993",
				Image:       "test-service-1-app",
				Environment: "cluster1/dev",
				SourceImage: "master-3.0.0-3c3f993-ts241014180403",
				UpdatedAt:   time.Now().String(),
			},
			"test-service-2-app": {
				Name:        "test-service-1-job",
				Namespace:   "dev",
				Kind:        "batch",
				Version:     "master-3.0.0-3c3f993",
				Image:       "test-service-1-job",
				Environment: "cluster1/dev",
				SourceImage: "master-3.0.0-3c3f993-ts241014180403",
				UpdatedAt:   time.Now().Add(-24 * time.Hour).String(),
			},
		},
		"cluster2/stable": {
			"test-service-1-app": {
				Name:        "test-service-1-app",
				Namespace:   "stable",
				Kind:        "v1",
				Version:     "master-2.0.0-3c3f992",
				Image:       "test-service-1-app",
				SourceImage: "master-2.0.0-3c3f992-ts241014180402",
				Environment: "cluster2/stable",
				UpdatedAt:   time.Now().String(),
			},
			"test-service-2-app": {
				Name:        "test-service-1-job",
				Namespace:   "stable",
				Kind:        "batch",
				Version:     "master-3.0.0-3c3f993",
				Image:       "test-service-1-job",
				SourceImage: "master-3.0.0-3c3f993-ts241014180403",
				Environment: "cluster2/stable",
				UpdatedAt:   time.Now().Add(-24 * time.Hour).String(),
			},
		},
		"cluster3/prod": {
			"test-service-1-app": {
				Name:        "test-service-1-app",
				Namespace:   "prod",
				Kind:        "v1",
				Version:     "master-1.0.0-3c3f991",
				Image:       "test-service-1-app",
				SourceImage: "master-1.0.0-3c3f991-ts241014180401",
				Environment: "cluster3/prod",
				UpdatedAt:   time.Now().String(),
			},
			"test-service-2-app": {
				Name:        "test-service-1-job",
				Namespace:   "prod",
				Kind:        "batch",
				Version:     "master-1.0.0-3c3f991",
				Image:       "test-service-1-job",
				SourceImage: "master-1.0.0-3c3f991-ts241014180401",
				Environment: "cluster3/prod",
				UpdatedAt:   time.Now().Add(-24 * time.Hour).String(),
			},
		},
	}
	ac.Apps = testAppsCache

	// Mock NewClientSetFunc
	originalNewClientSetFunc := NewClientSetFunc
	NewClientSetFunc = func(ctx context.Context, projectID, clusterName, zone string) (*kubernetes.Clientset, *rest.Config, error) {
		return nil, &rest.Config{}, nil
	}

	//
	// Initialize OpenTelemetry
	metrics, err = telemetry.InitTelemetry(context.Background(), serverFlags.ServiceName, appVersion)
	if err != nil {
		log.Error().Msgf("failed to initialize telemetry: %v", err)
	}

	// Return a cleanup function
	cleanup := func() {
		// tempDB.Close()
		// DataDB = originalDbMain
		NewClientSetFunc = originalNewClientSetFunc
	}

	return ac, fakeClient, apps, validator, environments, cleanup
}

func generateApplications(namespace string, count int, suffix string, componentGroupKinds []metav1.GroupKind) []client.Object {
	applications := make([]client.Object, count)
	for i := 0; i < count; i++ {
		ts := 241014180403
		commitHash := "3c3f99"
		patch := 2

		if namespace == "prod" {
			patch = 1
			ts = 241014170403
			commitHash = "g61660"
		}
		name := fmt.Sprintf("test-service-%d%s", i+1, suffix)
		ver := fmt.Sprintf("1.%d.%d-%s", i, patch, commitHash)
		image := name
		version := fmt.Sprintf("master-%s-ts%d", ver, ts)

		app := &applicationsv1beta1.Application{
			ObjectMeta: metav1.ObjectMeta{
				Name:      name,
				Namespace: namespace,
				Labels: map[string]string{
					"app.kubernetes.io/name": name,
					"version":                version,
					"image":                  image,
				},
			},
			Spec: applicationsv1beta1.ApplicationSpec{
				Descriptor: applicationsv1beta1.Descriptor{
					Version: version,
				},
				ComponentGroupKinds: componentGroupKinds,
			},
		}

		applications[i] = app
	}
	return applications
}

// getApplicationsList retrieves a list of Application resources from a specified namespace using a Kubernetes client.
func getApplicationsList(k8sClient client.Client, namespace string) (applicationsv1beta1.ApplicationList, error) {

	// List all Application resources in a namespace
	var appList applicationsv1beta1.ApplicationList
	if err := k8sClient.List(context.TODO(), &appList, &client.ListOptions{
		Namespace: namespace,
	}); err != nil {
		return applicationsv1beta1.ApplicationList{}, err
	}

	return appList, nil
}

func TestExecute(t *testing.T) {
	tests := []struct {
		name          string
		args          []string
		expectedError bool
		contains      string
	}{
		{
			name:          "Help command",
			args:          []string{"--help"},
			expectedError: false,
		},
		{
			name:          "Invalid flag",
			args:          []string{"--invalid-flag"},
			expectedError: false,
		},
		{
			name:          "Version flag",
			args:          []string{"--version"},
			expectedError: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Save original args and restore after test
			oldArgs := os.Args
			defer func() { os.Args = oldArgs }()
			os.Args = tt.args

			// Capture stdout and stderr
			oldOut := os.Stdout
			oldErr := os.Stderr
			r, w, _ := os.Pipe()
			os.Stdout = w
			os.Stderr = w

			// Create a channel to capture exit code
			exit := make(chan int, 1)
			oldOsExit := osExit
			defer func() { osExit = oldOsExit }()
			osExit = func(code int) {
				exit <- code
				// Don't actually exit
			}

			// Execute in a goroutine
			go func() {
				Execute()
				close(exit)
			}()

			// Wait for execution
			w.Close()
			os.Stdout = oldOut
			os.Stderr = oldErr

			// Read output
			var buf bytes.Buffer
			buf.ReadFrom(r)
			output := buf.String()
			t.Logf("output: %s", output)

			// Check exit code
			var exitCode int
			select {
			case code := <-exit:
				exitCode = code
			case <-time.After(time.Second):
				// Timeout, no exit called
				exitCode = 0
			}

			if tt.expectedError {
				assert.Equal(t, 1, exitCode, "Expected error exit code")
			} else {
				assert.Equal(t, 0, exitCode, "Expected success exit code")
			}

			assert.Contains(t, output, tt.contains)
		})
	}
}

// Mock os.Exit for testing
var osExit = os.Exit

// TestConfigureLogger tests the configureLogger function
func TestConfigureLogger(t *testing.T) {
	// Capture the original log level
	originalLevel := zerolog.GlobalLevel()

	// Test cases
	tests := []struct {
		name      string
		rootFlags *AppFlags
		expected  zerolog.Level
	}{
		{"Trace Level", &AppFlags{LogLevel: LogLevelTrace}, zerolog.TraceLevel},
		{"Debug Level", &AppFlags{LogLevel: LogLevelDebug}, zerolog.DebugLevel},
		{"Info Level", &AppFlags{LogLevel: LogLevelInfo}, zerolog.InfoLevel},
		{"Default Level", &AppFlags{}, zerolog.InfoLevel},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			rootFlags = *tt.rootFlags // Set the appFlags for the test
			configureLogger()         // Call the function to configure the logger

			if zerolog.GlobalLevel() != tt.expected {
				t.Errorf("expected log level %v, got %v", tt.expected, zerolog.GlobalLevel())
			}
		})
	}

	// Restore the original log level
	zerolog.SetGlobalLevel(originalLevel)
}
